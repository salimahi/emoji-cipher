<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Emoji Cipherâ„¢ â€“ Puzzle</title>
  <meta name="description" content="Emoji Cipherâ„¢ is an original logic puzzle by Salimah Ismail. Decode the emojis to reveal the hidden phrase and balance the equations.">
  <meta name="author" content="Salimah Ismail">
  <meta name="copyright" content="Â© 2025 Salimah Ismail. Licensed under CC BY-NC-ND 4.0 International.">
  <meta name="license" content="https://creativecommons.org/licenses/by-nc-nd/4.0/">
  <style>
    body {
      font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",sans-serif;
      margin: 2rem auto;
      max-width: 640px;
      line-height: 1.5;
      color: #222;
      background: #fdfdfd;
    }
    h1, h2 { text-align: center; }

    .note-box {
      background: #fff8db;
      border: 1px solid #e6d78a;
      border-radius: .5rem;
      padding: .75rem;
      margin-bottom: 1rem;
      font-size: .9rem;
    }

    .section-title{
      font-size:1rem;
      font-weight:600;
      margin:1.5rem 0 .5rem;
      text-transform:uppercase;
      letter-spacing:.03em;
      color:#444;
    }

    /* Phrase layout */
    .phrase-wrapper {
      background:#fff;
      border:1px solid #ddd;
      border-radius:.5rem;
      padding:1rem;
      box-shadow:0 1px 2px rgb(0 0 0 / .05);
      display:flex;
      flex-wrap:wrap;
      gap:1rem 1rem; /* gap between words */
    }

    .word-block {
      display:flex;
      flex-wrap:nowrap;
      gap:.75rem; /* gap between letters in same word */
    }

    .char-stack {
      display:flex;
      flex-direction:column;
      align-items:center;
      min-width:2.2rem;
    }

    .char-input {
      width:2.2rem;
      height:2.2rem;
      font-size:1.1rem;
      text-align:center;
      font-weight:600;
      border:1.5px solid #bbb;
      border-radius:.5rem;
      background:#fff;
      box-shadow:0 1px 2px rgb(0 0 0 / 0.05);
      font-family:inherit;
    }
    .char-input:focus{
      outline:none;
      border-color:#000;
    }
    .char-input[disabled]{
      background:#e6ffe6;
      border-color:#108a00;
      color:#0a4f00;
      font-weight:600;
    }

    .char-emoji {
      font-size:1.4rem;
      line-height:1.2;
      margin-top:.25rem;
    }

    /* Equations block */
    .equations-wrapper{
      border:1px solid #ddd;
      border-radius:.5rem;
      background:#fff;
      box-shadow:0 1px 2px rgb(0 0 0 / .05);
      padding:.5rem .75rem;
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      font-size:.9rem;
    }

    .equation-row{
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:.5rem .75rem;
      padding:.75rem 0;
      border-bottom:1px solid #eee;
    }
    .equation-row:last-child{border-bottom:none;}

    .eq-left {
      display:flex;
      flex-wrap:wrap;
      gap:.5rem .75rem;
      align-items:center;
    }

    .eq-stack {
      display:flex;
      flex-direction:column;
      align-items:center;
      min-width:2.2rem;
    }
    .num-input {
      width:2.2rem;
      height:2.2rem;
      font-size:1rem;
      text-align:center;
      font-weight:600;
      border:1.5px solid #bbb;
      border-radius:.5rem;
      background:#fff;
      box-shadow:0 1px 2px rgb(0 0 0 / 0.05);
      font-family:inherit;
    }
    .num-input:focus{
      outline:none;
      border-color:#000;
    }
    .num-input[disabled]{
      background:#e6ffe6;
      border-color:#108a00;
      color:#0a4f00;
      font-weight:600;
    }

    .eq-target {
      font-weight:600;
    }

    .eq-result {
      font-weight:600;
      min-width:2rem;
      text-align:center;
    }
    .status-ok{color:#108a00;}
    .status-bad{color:#b00020;}

    /* Mapping grid */
    .mapping-row {
      display:grid;
      grid-template-columns:2rem 1fr 1fr;
      align-items:center;
      gap:.5rem;
      padding:.5rem .75rem;
      border:1px solid #ddd;
      border-radius:.5rem;
      background:#fafafa;
      margin-bottom:.5rem;
      box-shadow:0 1px 2px rgb(0 0 0 / .05);
      transition: background-color .15s ease, box-shadow .15s ease;
    }
    .mapping-row.solved {
      background:#e6ffe6;
      box-shadow:0 0 0 2px #108a0044 inset;
    }
    .emoji-cell{font-size:1.5rem;text-align:center;}
    label{display:block;font-size:.7rem;font-weight:500;color:#555;margin-bottom:.25rem;}
    input[type="text"],input[type="number"]{
      width:100%;
      font-size:1rem;
      padding:.4rem .5rem;
      border:1px solid #bbb;
      border-radius:.4rem;
      font-family:inherit;
      background:white;
    }
    input:focus{border-color:#000;outline:none;}
    input[disabled]{
      background:#e6ffe6;
      border-color:#108a00;
      color:#0a4f00;
      font-weight:600;
    }

    .win-box{
      margin-top:1rem;
      border-radius:.75rem;
      padding:1rem;
      font-weight:600;
      text-align:center;
      font-size:1rem;
      display:none;
      background:#e6ffe6;
      border:2px solid #108a00;
      color:#0a4f00;
      box-shadow:0 4px 10px rgb(0 0 0 / .08);
    }

    footer{
      margin-top:2rem;
      font-size:.8rem;
      text-align:center;
      color:#666;
    }
    footer a{
      color:#555;
      text-decoration:none;
    }
  </style>
</head>
<body>
  <h1>Emoji Cipherâ„¢</h1>
  <h2>Puzzle</h2>

  <div class="note-box">
    Each emoji stands for <strong>one letter</strong> AND <strong>one number</strong>.<br>
    Type directly into the boxes above each emoji.<br>
    If you solve either the letter OR the number for an emoji, we'll fill in the rest and lock it.
  </div>

  <div class="section-title">Your Decoded Phrase</div>
  <div class="phrase-wrapper" id="phraseArea"></div>

  <div class="section-title">Check the Math</div>
  <div class="equations-wrapper" id="equationsArea"></div>

  <div class="section-title">Assign Letters and Numbers</div>
  <div id="mappingInputs"></div>

  <div class="win-box" id="winBox">
    âœ… You solved it!
  </div>

  <footer>
    Emoji Cipherâ„¢ Â© 2025 Salimah Ismail.<br>
    Licensed under <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0 International</a>.
  </footer>

  <script>
  (function(){

    // We'll start with just one puzzle: "COOL GAME BRO"
    const currentPuzzle = {
      phrase: "COOL GAME BRO",
      // words broken into arrays of emojis
      phraseWords: [
        ["ðŸ¦Š","ðŸª","ðŸª","ðŸ¸"],        // COOL
        ["ðŸš€","ðŸŒµ","ðŸŽ²","ðŸ”®"],        // GAME
        ["ðŸ§Š","ðŸŒµ","ðŸª"]             // BRO
      ],
      // correct solution for each emoji
      mapping: {
        "ðŸ¦Š": { letter:"C", number:3 },
        "ðŸª": { letter:"O", number:8 },
        "ðŸ¸": { letter:"L", number:4 },
        "ðŸš€": { letter:"G", number:7 },
        "ðŸŒµ": { letter:"A", number:1 },
        "ðŸŽ²": { letter:"M", number:6 },
        "ðŸ”®": { letter:"E", number:2 },
        "ðŸ§Š": { letter:"B", number:5 }
      },
      uniqueEmojis: ["ðŸ¦Š","ðŸª","ðŸ¸","ðŸš€","ðŸŒµ","ðŸŽ²","ðŸ”®","ðŸ§Š"],
      equations: [
        { left:["ðŸ¦Š","+","ðŸª"], target:11 },              // 3 + 8
        { left:["ðŸª","+","ðŸ¸"], target:12 },              // 8 + 4
        { left:["ðŸš€","+","ðŸŒµ","+","ðŸŽ²"], target:14 },     // 7 + 1 + 6
        { left:["ðŸŽ²","+","ðŸ”®"], target:8 },              // 6 + 2
        { left:["ðŸ§Š","+","ðŸŒµ"], target:6 }               // 5 + 1
      ]
    };

    // State for each emoji: did we solve it yet?
    // { [emoji]: {letter:"", number:"", solved:false} }
    const playerState = {};
    currentPuzzle.uniqueEmojis.forEach(em=>{
      playerState[em] = { letter:"", number:"", solved:false };
    });

    // DOM elements
    const phraseArea      = document.getElementById("phraseArea");
    const equationsArea   = document.getElementById("equationsArea");
    const mappingContainer= document.getElementById("mappingInputs");
    const winBox          = document.getElementById("winBox");

    // --- Rendering the PHRASE -------------------------------------------------
    // We'll render each word as .word-block
    // each character slot as:
    // <div class="char-stack" data-emoji="ðŸ¦Š">
    //    <input class="char-input" ... />
    //    <div class="char-emoji">ðŸ¦Š</div>
    // </div>
    function renderPhraseArea(){
      phraseArea.innerHTML = "";
      currentPuzzle.phraseWords.forEach((wordArr, wordIndex)=>{
        const wordBlock=document.createElement("div");
        wordBlock.className="word-block";

        wordArr.forEach((em, charIndex)=>{
          const stack=document.createElement("div");
          stack.className="char-stack";
          stack.dataset.emoji=em;
          stack.dataset.wordIndex=wordIndex;
          stack.dataset.charIndex=charIndex;

          const inp=document.createElement("input");
          inp.className="char-input";
          inp.maxLength=1;
          inp.dataset.emoji=em;
          inp.dataset.kind="letter"; // indicates letter-guess zone
          inp.addEventListener("input",handleGuessInput);

          // initial placeholder
          inp.value = "_";

          const emojiDiv=document.createElement("div");
          emojiDiv.className="char-emoji";
          emojiDiv.textContent=em;

          stack.appendChild(inp);
          stack.appendChild(emojiDiv);
          wordBlock.appendChild(stack);
        });

        phraseArea.appendChild(wordBlock);
      });
    }

    // --- Rendering the EQUATIONS --------------------------------------------
    // Each equation row:
    //
    // [num-slot over emoji] + [num-slot over emoji] = target âœ…/âŒ
    //
    // num-slot is basically the same idea as char-stack but for numbers

    function renderEquations(){
      equationsArea.innerHTML = "";

      currentPuzzle.equations.forEach((eqObj, eqIndex)=>{
        const row=document.createElement("div");
        row.className="equation-row";

        // left side: inputs and plus signs
        const leftWrap=document.createElement("div");
        leftWrap.className="eq-left";

        eqObj.left.forEach(token=>{
          if(token === "+"){
            const plusSpan=document.createElement("div");
            plusSpan.textContent="+";
            leftWrap.appendChild(plusSpan);
          } else {
            // emoji operand
            const stack=document.createElement("div");
            stack.className="eq-stack";
            stack.dataset.emoji=token;
            stack.dataset.eqIndex=eqIndex;

            const inp=document.createElement("input");
            inp.className="num-input";
            inp.maxLength=1;
            inp.dataset.emoji=token;
            inp.dataset.kind="number"; // indicates number-guess zone
            inp.addEventListener("input",handleGuessInput);

            inp.value = "_";

            const emDiv=document.createElement("div");
            emDiv.className="char-emoji";
            emDiv.textContent=token;

            stack.appendChild(inp);
            stack.appendChild(emDiv);
            leftWrap.appendChild(stack);
          }
        });

        // target number
        const targetDiv=document.createElement("div");
        targetDiv.className="eq-target";
        targetDiv.textContent="= "+eqObj.target;

        // result check
        const resultDiv=document.createElement("div");
        resultDiv.className="eq-result status-bad";
        resultDiv.dataset.eqIndex=eqIndex;
        resultDiv.textContent="âŒ";

        row.appendChild(leftWrap);
        row.appendChild(targetDiv);
        row.appendChild(resultDiv);

        equationsArea.appendChild(row);
      });

      // After render, validate equations once (everything will be âŒ at first)
      updateEquationsStatus();
    }

    // --- Rendering the MAPPING PANEL ----------------------------------------
    // One row per emoji, with Letter and Number inputs. These autofill + lock
    // when solved from anywhere else.

    function renderMappingInputs(){
      mappingContainer.innerHTML = "";
      currentPuzzle.uniqueEmojis.forEach(em=>{
        const row=document.createElement("div");
        row.className="mapping-row";
        row.setAttribute("data-row-emoji", em);

        const emojiCell=document.createElement("div");
        emojiCell.className="emoji-cell";
        emojiCell.textContent=em;
        row.appendChild(emojiCell);

        // Letter input
        const letterWrap=document.createElement("div");
        const letterLabel=document.createElement("label");
        letterLabel.textContent="Letter";
        const letterInput=document.createElement("input");
        letterInput.type="text";
        letterInput.maxLength=1;
        letterInput.dataset.emoji=em;
        letterInput.dataset.kind="letter";
        letterInput.addEventListener("input",handleGuessInput);
        letterWrap.appendChild(letterLabel);
        letterWrap.appendChild(letterInput);

        // Number input
        const numberWrap=document.createElement("div");
        const numberLabel=document.createElement("label");
        numberLabel.textContent="Number (0-9)";
        const numberInput=document.createElement("input");
        numberInput.type="number";
        numberInput.min="0";
        numberInput.max="9";
        numberInput.dataset.emoji=em;
        numberInput.dataset.kind="number";
        numberInput.addEventListener("input",handleGuessInput);
        numberWrap.appendChild(numberLabel);
        numberWrap.appendChild(numberInput);

        row.appendChild(letterWrap);
        row.appendChild(numberWrap);

        mappingContainer.appendChild(row);
      });
    }

    // --- HANDLE GUESSES ------------------------------------------------------
    // This single handler is used for:
    // - Letter guesses in phrase inputs
    // - Number guesses in equations
    // - Letter/Number guesses in mapping panel
    //
    // We'll:
    // 1. Normalize guess (upper-case letter or 0-9 digit).
    // 2. Check against correct mapping for this emoji.
    // 3. If correct, lock that emoji everywhere.
    // 4. Re-check equations and win state.
    function handleGuessInput(e){
      const em = e.target.dataset.emoji;
      const kind = e.target.dataset.kind; // "letter" or "number"
      if(playerState[em].solved){
        // Already solved -> force correct values and bail
        applySolutionToEmoji(em);
        return;
      }

      let val = e.target.value;

      if(kind==="letter"){
        // normalize: only A-Z, uppercase
        val = val.toUpperCase().replace(/[^A-Z]/g,"").slice(0,1);
        e.target.value = val || "_";
      } else if(kind==="number"){
        // normalize: digit 0-9
        if(val!==""){
          let n=parseInt(val,10);
          if(isNaN(n)) n="";
          if(n<0) n=0;
          if(n>9) n=9;
          e.target.value = n || "_";
          val = e.target.value;
        }
      }

      // Compare guess to truth
      const correctLetter = currentPuzzle.mapping[em].letter;
      const correctNumber = String(currentPuzzle.mapping[em].number);

      const solvedByLetter = (kind==="letter" && val === correctLetter);
      const solvedByNumber = (kind==="number" && val === correctNumber);

      if(solvedByLetter || solvedByNumber){
        // mark emoji as solved globally
        playerState[em].solved = true;
        playerState[em].letter = correctLetter;
        playerState[em].number = correctNumber;

        applySolutionToEmoji(em);
        updateEquationsStatus();
        checkWin();
      } else {
        // not solved yet -> just update partial guess to state
        if(kind==="letter"){
          playerState[em].letter = val;
        } else {
          playerState[em].number = val;
        }
        updateEquationsStatus();
        checkWin();
      }
    }

    // applySolutionToEmoji:
    // - fill + disable all phrase char-inputs for this emoji
    // - fill + disable all equation num-inputs for this emoji
    // - fill + disable both inputs in the mapping row for this emoji
    // - visually mark solved rows
    function applySolutionToEmoji(em){
      const finalLetter = currentPuzzle.mapping[em].letter;
      const finalNumber = String(currentPuzzle.mapping[em].number);

      // phrase char-inputs
      const phraseInputs = phraseArea.querySelectorAll(`.char-input[data-emoji="${em}"]`);
      phraseInputs.forEach(inp=>{
        inp.value = finalLetter;
        inp.disabled = true;
      });

      // equation num-inputs
      const eqInputs = equationsArea.querySelectorAll(`.num-input[data-emoji="${em}"]`);
      eqInputs.forEach(inp=>{
        inp.value = finalNumber;
        inp.disabled = true;
      });

      // mapping row
      const row = mappingContainer.querySelector(`[data-row-emoji="${em}"]`);
      if(row){
        row.classList.add("solved");
        const rowInputs = row.querySelectorAll("input");
        rowInputs.forEach(rinp=>{
          if(rinp.dataset.kind==="letter"){
            rinp.value = finalLetter;
          }
          if(rinp.dataset.kind==="number"){
            rinp.value = finalNumber;
          }
          rinp.disabled = true;
        });
      }
    }

    // --- EQUATION CHECKING ---------------------------------------------------
    function updateEquationsStatus(){
      // For each equation row, compute sum of its operands (if known)
      // If all operands have digits and sum === target -> âœ… else âŒ
      currentPuzzle.equations.forEach((eqObj, eqIndex)=>{
        let allKnown=true;
        let total=0;
        eqObj.left.forEach(token=>{
          if(token==="+") return;
          if(playerState[token].solved){
            total += currentPuzzle.mapping[token].number;
          } else {
            allKnown=false;
          }
        });

        const resultDiv = equationsArea.querySelector(`.eq-result[data-eq-index="${eqIndex}"]`);
        if(!resultDiv) return;
        if(allKnown && total===eqObj.target){
          resultDiv.textContent="âœ…";
          resultDiv.classList.remove("status-bad");
          resultDiv.classList.add("status-ok");
        } else {
          resultDiv.textContent="âŒ";
          resultDiv.classList.remove("status-ok");
          resultDiv.classList.add("status-bad");
        }
      });
    }

    // --- WIN CHECK -----------------------------------------------------------
    // We read the phrase from the UI: all .char-inputs in order.
    function getCurrentPhraseGuess(){
      // join all words with space
      const wordsGuesses = [];
      // phraseArea children are .word-blocks
      const wordBlocks = phraseArea.querySelectorAll(".word-block");
      wordBlocks.forEach(block=>{
        let wordGuess="";
        const inputs=block.querySelectorAll(".char-input");
        inputs.forEach(inp=>{
          // if it's still "_", treat as blank
          const v = inp.value.trim();
          if(v==="_" || v==="") {
            wordGuess += "_";
          } else {
            wordGuess += v;
          }
        });
        wordsGuesses.push(wordGuess);
      });
      return wordsGuesses.join(" ");
    }

    function checkWin(){
      const solvedPhrase = getCurrentPhraseGuess() === currentPuzzle.phrase;
      // all equations must pass AND solvedPhrase true
      let allEqCorrect=true;
      currentPuzzle.equations.forEach((eqObj, eqIndex)=>{
        const resDiv = equationsArea.querySelector(`.eq-result[data-eq-index="${eqIndex}"]`);
        if(!resDiv || !resDiv.classList.contains("status-ok")){
          allEqCorrect=false;
        }
      });

      if(solvedPhrase && allEqCorrect){
        winBox.style.display = "block";
      } else {
        winBox.style.display = "none";
      }
    }

    // --- INIT ---------------------------------------------------------------
    function init(){
      renderPhraseArea();
      renderEquations();
      renderMappingInputs();
      // nothing is solved by default, so no autofill
    }

    init();

  })();
  </script>
</body>
</html>
